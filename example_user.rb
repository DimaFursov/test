class User
  attr_accessor :name, :email

  def initialize(attributes = {})
    @name  = attributes[:name] # переменных экземпляра заключается в том, что они автоматически доступны в представлениях
    @email = attributes[:email]
  end

  def formatted_email
    "#{@name} <#{@email}>"
  end
end
=begin
user.errors
создаёт методы доступа к атрибутам, соответствующие имени пользователя и адресу электронной почты. При этом появлюятся два метода — “getter” (получатель) и “setter” (назначатель), которые позволяют получать (get) и назначать (set) переменные экземпляра @name и @email, которые были вкратце упомянуты в Разделе 2.2.2 и Разделе 3.6. В Rails принципиальная важность переменных экземпляра заключается в том, что они автоматически доступны в представлениях, но в общем случае они используются для переменных, которые должны быть доступны в Ruby-классе повсеместно. (Мы вскоре расскажем об этом более подробно.) Переменные экземпляра всегда начинаются со знака  @ и являются nil, если не определены.

Первый метод — initialize — специальный в Ruby: он вызывается, когда мы выполняем User.new. Конкретно этот initialize принимает один аргумент, attributes:

  def initialize(attributes = {})
    @name  = attributes[:name]
    @email = attributes[:email]
  end
Здесь для переменной attributes устанавливается значение по умолчанию, равное пустому хэшу, так что мы можем определить пользователя без имени или адреса электронной почты. (Напомним, из Раздела 4.3.3, что хэши возвращают nil на несуществующие ключи, поэтому attributes[:name] будет nil, если нет ключа :name, так же для attributes[:email].)

Наконец, наш класс определяет метод formatted_email, который использует значения, присваиваемые переменным @name и @email, для создания отформатированной версии адреса электронной почты пользователя, с помощью интерполяции строки (Раздел 4.2.2):

  def formatted_email
    "#{@name} <#{@email}>"
  end
Переменные @name и @email автоматически доступны в методе formatted_email, так как они являются переменными экземпляра (на это указывает знак @).

User класс:
>> require './example_user'     # Так вы загружаете код example_user.
=> true
>> example = User.new
=> #<User:0x224ceec @email=nil, @name=nil>
>> example.name                 # nil, поскольку attributes[:name] - nil
=> nil
>> example.name = "Example User"           # Назначение не-nil имени
=> "Example User"
>> example.email = "user@example.com"      # и не-nil email адреса
=> "user@example.com"
>> example.formatted_email
=> "Example User <user@example.com>"
Здесь ’.’ — обозначение Unix для “текущего каталога”, и ’./example_user’ говорит Ruby искать файл примера пользователя относительно этого расположения. Последующий код создает пустого пользователя, а затем заполняет имя и адрес электронной почты присвоением непосредственно к соответствующим атрибутам (это стало возможными благодаря строке attr_accessor в Листинге 4.13). Когда мы пишем

example.name = "Example User"
Ruby создаёт переменную @name для "Example User" (и аналогично для атрибута email), которая затем используется в методе formatted_email.

Вспомнив Раздел 4.3.4, мы можем опустить фигурные скобки для последнего хеш-аргумента; можно создать другого пользователя, передавая хэш методу initialize для создания пользователя с заранее определенными атрибутами:

>> user = User.new(name: "Michael Hartl", email: "mhartl@example.com")
=> #<User:0x225167c @email="mhartl@example.com", @name="Michael Hartl">
>> user.formatted_email
=> "Michael Hartl <mhartl@example.com>"
=end